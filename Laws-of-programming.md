## KISS (Keep It Simple, Stupid):

    Mantén el diseño lo más simple posible. La simplicidad debería ser un objetivo clave en el diseño y programación, ya que sistemas más simples son más fáciles de entender, mantener y extender.

## DRY (Don't Repeat Yourself):

    Evita la duplicación de código. Cada pieza de conocimiento o lógica debería tener una única representación en el sistema.

## YAGNI (You Aren't Gonna Need It):

    No añadas funcionalidad hasta que realmente sea necesaria. Evita el desarrollo de características que no se usarán en un futuro inmediato.

## SOLID:

    Un conjunto de principios de diseño de programación orientada a objetos que ayudan a hacer el software más comprensible, flexible y mantenible.
        S: Single Responsibility Principle (Principio de responsabilidad única).
        O: Open/Closed Principle (Principio de abierto/cerrado).
        L: Liskov Substitution Principle (Principio de sustitución de Liskov).
        I: Interface Segregation Principle (Principio de segregación de la interfaz).
        D: Dependency Inversion Principle (Principio de inversión de dependencias).

## Boy Scout Rule:

    Deja el código más limpio de lo que lo encontraste. Mejorar continuamente el código para hacerlo más limpio y eficiente.

## Law of Demeter:

    Cada módulo debe conocer lo menos posible de otros módulos. Promueve el desacoplamiento y la encapsulación.

## Separation of Concerns:

    Divide el programa en secciones distintas, cada una de las cuales aborda una preocupación separada. Facilita la comprensión, mantenimiento y escalabilidad del código.

## Fail Fast:

    Detecta errores lo antes posible. Si un sistema va a fallar, debería hacerlo lo antes posible para minimizar el impacto y facilitar la depuración.

## Principle of Least Astonishment:

    El comportamiento del código debe ser intuitivo y cumplir con las expectativas del usuario. El diseño debería minimizar la sorpresa para los desarrolladores y usuarios.

## Code for the Maintainer:

    Escribe código que sea fácil de entender y mantener. Ten en cuenta que el próximo desarrollador que trabaje con tu código podría ser tú mismo.
